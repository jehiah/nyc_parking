// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ParkingLocationMetadata Metadata about a single parking location (everything that doesn't tell you
// who can park there, when, or for how much).
//
// swagger:model ParkingLocationMetadata
type ParkingLocationMetadata struct {

	// The address of the parking location.
	//
	Address string `json:"address,omitempty"`

	// A list of amenities at the location.
	Amenities []string `json:"amenities"`

	// The time (in seconds since the UTC Unix epoch) this location was first
	// created.
	//
	Created int64 `json:"created,omitempty"`

	// The ID of the parking location whose availability is being
	// represented here. An ID uniquely identifies a given lot or garage.
	//
	// Required: true
	ID *string `json:"id"`

	// The time (in seconds since the UTC Unix epoch) this location was last
	// updated. This includes updates to occupancy/availability data.
	//
	LastUpdated int64 `json:"last_updated,omitempty"`

	// A descriptive name for the parking location.
	Name string `json:"name,omitempty"`

	// The type of access available for this location, via the Flow /access/parking API.
	// * not_available: This location may not be accessed via the API. Your end users can still
	//   access the location via means advertised at the physical location.
	// * license_plate: This location may be accessed via the API, as long as
	//   license plates are associated with the User objects you've created on behalf of your
	//   users. See the Parking Access API documentation (https://coord.co/docs/accessparking)
	//   for more info on how to create and end sessions.
	// * barcode: This location may be accessed via the API, but your end users must display a
	//   properly formatted barcode upon arriving at the parking location. See the
	//   Parking Access API documentation (https://coord.co/docs/accessparking)
	//   for more info on how to create sessions requiring on-site redemption.
	//
	// Enum: [not_available license_plate barcode]
	OnlineAccessType string `json:"online_access_type,omitempty"`

	// The name of the operator of the parking location.
	OperatorName string `json:"operator_name,omitempty"`

	// The time zone (see https://www.iana.org/time-zones) this location is in.
	//
	TimeZone string `json:"time_zone,omitempty"`
}

// Validate validates this parking location metadata
func (m *ParkingLocationMetadata) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAmenities(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOnlineAccessType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var parkingLocationMetadataAmenitiesItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["covered","valet"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		parkingLocationMetadataAmenitiesItemsEnum = append(parkingLocationMetadataAmenitiesItemsEnum, v)
	}
}

func (m *ParkingLocationMetadata) validateAmenitiesItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, parkingLocationMetadataAmenitiesItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *ParkingLocationMetadata) validateAmenities(formats strfmt.Registry) error {

	if swag.IsZero(m.Amenities) { // not required
		return nil
	}

	for i := 0; i < len(m.Amenities); i++ {

		// value enum
		if err := m.validateAmenitiesItemsEnum("amenities"+"."+strconv.Itoa(i), "body", m.Amenities[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *ParkingLocationMetadata) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

var parkingLocationMetadataTypeOnlineAccessTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["not_available","license_plate","barcode"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		parkingLocationMetadataTypeOnlineAccessTypePropEnum = append(parkingLocationMetadataTypeOnlineAccessTypePropEnum, v)
	}
}

const (

	// ParkingLocationMetadataOnlineAccessTypeNotAvailable captures enum value "not_available"
	ParkingLocationMetadataOnlineAccessTypeNotAvailable string = "not_available"

	// ParkingLocationMetadataOnlineAccessTypeLicensePlate captures enum value "license_plate"
	ParkingLocationMetadataOnlineAccessTypeLicensePlate string = "license_plate"

	// ParkingLocationMetadataOnlineAccessTypeBarcode captures enum value "barcode"
	ParkingLocationMetadataOnlineAccessTypeBarcode string = "barcode"
)

// prop value enum
func (m *ParkingLocationMetadata) validateOnlineAccessTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, parkingLocationMetadataTypeOnlineAccessTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *ParkingLocationMetadata) validateOnlineAccessType(formats strfmt.Registry) error {

	if swag.IsZero(m.OnlineAccessType) { // not required
		return nil
	}

	// value enum
	if err := m.validateOnlineAccessTypeEnum("online_access_type", "body", m.OnlineAccessType); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ParkingLocationMetadata) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ParkingLocationMetadata) UnmarshalBinary(b []byte) error {
	var res ParkingLocationMetadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
