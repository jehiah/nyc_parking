// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ParkingSession Information about a specific parking session.
// swagger:model ParkingSession
type ParkingSession struct {

	// billing info
	BillingInfo *ParkingSessionBillingInfo `json:"billing_info,omitempty"`

	// The time at which resource usage ended.
	// Format: date-time
	EndTime *strfmt.DateTime `json:"end_time,omitempty"`

	// The unique identifier for the session, created by the server. Any non-server filled value
	// will be ignored. Note that session ids are only unique within the location at which the
	// session is being created. As such, to uniquely identify a session, you must also keep
	// track of the location at which the session was started.
	//
	ID int64 `json:"id,omitempty"`

	// The parking location where the session takes place.
	LocationID string `json:"location_id,omitempty"`

	// redemption info
	RedemptionInfo *RedemptionInfo `json:"redemption_info,omitempty"`

	// Text identifying the specific resource that's being reserved/used. This could be a stall
	// number for a car in a parking lot, a charger number, or pump number, etc
	//
	ResourceID string `json:"resource_id,omitempty"`

	// The time at which resource usage started.
	// Format: date-time
	StartTime *strfmt.DateTime `json:"start_time,omitempty"`

	// The Flow user_id of the user on behalf of whom the session is being created. This user
	// must be pre-registered with the system using the User API (see
	// https://coord.co/docs/users).
	//
	UserID string `json:"user_id,omitempty"`
}

// Validate validates this parking session
func (m *ParkingSession) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBillingInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEndTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRedemptionInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartTime(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ParkingSession) validateBillingInfo(formats strfmt.Registry) error {

	if swag.IsZero(m.BillingInfo) { // not required
		return nil
	}

	if m.BillingInfo != nil {
		if err := m.BillingInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billing_info")
			}
			return err
		}
	}

	return nil
}

func (m *ParkingSession) validateEndTime(formats strfmt.Registry) error {

	if swag.IsZero(m.EndTime) { // not required
		return nil
	}

	if err := validate.FormatOf("end_time", "body", "date-time", m.EndTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ParkingSession) validateRedemptionInfo(formats strfmt.Registry) error {

	if swag.IsZero(m.RedemptionInfo) { // not required
		return nil
	}

	if m.RedemptionInfo != nil {
		if err := m.RedemptionInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("redemption_info")
			}
			return err
		}
	}

	return nil
}

func (m *ParkingSession) validateStartTime(formats strfmt.Registry) error {

	if swag.IsZero(m.StartTime) { // not required
		return nil
	}

	if err := validate.FormatOf("start_time", "body", "date-time", m.StartTime.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ParkingSession) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ParkingSession) UnmarshalBinary(b []byte) error {
	var res ParkingSession
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ParkingSessionBillingInfo Information relating to billing for this session. Only set for ended sessions,
//
// swagger:model ParkingSessionBillingInfo
type ParkingSessionBillingInfo struct {

	// The cost of the session. If null, the total cost could not yet be calculated and
	// thus should not be displayed to your user. You may or may not be charged at billing
	// time depending on your agreement.
	//
	Cost *Money `json:"cost,omitempty"`
}

// Validate validates this parking session billing info
func (m *ParkingSessionBillingInfo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCost(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ParkingSessionBillingInfo) validateCost(formats strfmt.Registry) error {

	if swag.IsZero(m.Cost) { // not required
		return nil
	}

	if m.Cost != nil {
		if err := m.Cost.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billing_info" + "." + "cost")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ParkingSessionBillingInfo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ParkingSessionBillingInfo) UnmarshalBinary(b []byte) error {
	var res ParkingSessionBillingInfo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
